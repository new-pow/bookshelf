# 🤔 도메인 주도 설계의 사실과 오해
- 일시 : 2024. 9.
- 조용호 개발자 강의

## part1. DDD와 객체지향이 어떤 차이가 있는가
- 객체지향
	- 작은 목표를 구현하는 것
	- 코드 배치를 결정하는 것
- DDD
	- 크다
	- 조직적인 이슈까지 감.

### 도메인 주도 설계의 핵심
- 도메인 주도 설계는 복잡한 도메인을 다뤄야 하는 소프트웨어 프로젝트에 박차를 가하는 것을 목표로 삼는 사고 방식이자 우선순위의 모음이다.
- 도메인 Domain 이란?
	- 사용자가 프로그램을 사용하는 주제 영역
	- 어디까지 구현할 것인가? 범위 자르기
- 모델 이란?
	- 대상의 단순화
	- 수준 자르기
	- 왜 모델을 만들어야하는가? 여러 사람이랑 같이 눈높이view를 맞추기 위하여
- 도메인 모델 domain model
	- 사용자가 프로그램을 사용하는 주제 영역 안에서 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 세부사항은 생략한다.
	- DDD맥락에서 도메인 모델은 코드와 같다고 생각하면 된다.
- 모델 주도 설계 model-driven design
	- 모델과 핵심 설계는 서로 영향을 주며 반복을 통해 구체화된다
- 유비쿼터스 언어 ubiquitous language
	- 모델은 모든 팀 구성원들이 사용하는 언어의 중추
- 원래 DDD의 본질...
![[Pasted image 20240825144131.png]]
- 이렇게 하는 이유?
	- 이상적인 무엇인가를 만드는 것 X
	- 유지보수에 용이하기 위해서
		- 수정할 코드를 잘 찾는다 -> 사업에서 말하는 용어그대로 코드를 찾을 수 있다.
		- 사이드 이펙트가 적게 간다
		- ![[Pasted image 20240825144505.png]]
- 따라서 어떤 언어나 어떤 프로그래밍 패러다임을 전제하지 않습니다.
	- 그러나 DDD가 등장했던 2003년 상황에서는...
		- 객체지향, 애자일이 굉장히 떠오르고 있었다. -> 도메인 주도 설계의 개념적 바탕이 되었다.

### 객체지향 설계에서 도메인 주도 설계로
- 객체가 흥해진 이유?
	- GUI 때문
		- UI에서는 객체지향이다.
		- 상태가 있고, 메시지를 준다.
- 웹의 부상
	- 브라우저 성능이 떨어지자 애플리케이션 태어로 객체의 도메인 로직을 넘긴다.
	- ![[Pasted image 20240825145543.png]]
- 분산 객체 기술의 유행
	- EJB 컨테이너
	- 침투적인 아키텍처
		- 컨테이너의 기술 적인 지원을 받기 위해 EJB가 강요하는 인터페이스나 추상클래스 상속해야함
		- 비판 : 관심사 분리가 안된다. 서로 다른 이유로 바뀌는 것들을 뭉쳐놓으므로 변경가능성이 2배. 고려해야할 문제도 2배가 된다.
- POJO
	- plan old java object
	- 인프라에 의존성을 없애는 것.
	- spring 이 관심사를 분리할 수 있도록 도와줄게 :)
- 90년대에 기술에 대한 주목도가 컸기 때문에 이런 논의가 진행되었다.
- 도메인 주도 설계 출간
	- 기술적인 것을 제외하고 사고방식으로 나온 것이 DDD
- 분산 객체 기술의 문제점
	- 표현적 차이
		- 도메인에 대한 멘탈 모델과 소프트웨어 내부에 표현도니 도메인 개념 사이의 거리
		- 모델 주도 설계
	- 침투적인 기술로 인한 커뮤니케이션의 복잡성
		- 
	- 유비쿼터스 언어

## 모델주도설계의 빌딩 블록
### 도메인 로직의 격리
- 도메인 주도 설계의 전제 조건은 도메인 구현을 격리하는 것
- 레이어 아키텍처는 예시

### 모델 주도 설계의 빌딩 블록
- 구현 가능한 도메인 모델을 구성하는 요소들의 목록
- 가이드라인 빌딩블록
- 각 구성 요소에는 구현과 관련된 다양한 가정 내포
- 모델과 구현에 관한 의사 결정을 내리기 위해 필요한 용어 제공
- 도메인을 표현하기 위한 빌딩 블록
	- association
	- entity
	- value object
	- service
	- module
- 생명 주기를 관리하기 위한 빌딩 블록
	- aggregate
	- repository
	- factory
- 구현에 대한 가이드를 제공해서 복잡도를 낮추는 것
- 불변식 invariant
	- 항상 true여야 되는 식
	- 데이터 중심의 관점으로는 이 불변식이 깨질 수 있다.
	- -> aggregate 로 해결할 수 있음
### aggregate
- 불변식 (도메인의 룰)에 따름
- 트랜잭션의 단위
	- aggregate 단위로 트랜잭션 처리하면 됨.
- 저장 단위
- ![[Pasted image 20240825154313.png]]

### 참고자료
- 엔터프라이즈 애플리케이션 아키텍처 패턴
	- 도메인 모델 (패턴)
	- 트랜잭션 스크립트
	- 액티브 레코드 등의 용어 참고하기 좋음
- 트랜잭션 스크립트
	- 도메인 레이어
	- 메서드 하나에 스크립트 작성
	- 스크립트가 트랜잭션 단위로 작성됨. (트랜잭션 시작 - 로직 - 업데이트 - 트랜잭션 종료)
![[Pasted image 20240825154640.png]]

## 애자일과 도메인 주도 설계
- 애자일에서의 핵심
	- 코드레벨에서는 **리팩토링**
- 리팩터링
	- 소프트웨어의 겉보기 동작은 그대로 유지한 채 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 모델 주도 설계 Model driven design
	- 도메인 모델 변경 -> 코드 변경
![[Pasted image 20240825160744.png]]
- 완벽한 도메인을 처음부터 만들지 말자.
	- 점점 개선
![[Pasted image 20240825161410.png]]

## 전략적 설계
- 개발과 정치가 만나는 곳
- 시스템에서 도메인 모델은 여러개여야 한다.
- 응집도가 낮은 코드
	- SRP
	- 여러 사람이 함께 고치는 경우
- 코드 중복?
	- 나는 것이 나쁘지 않을 수 있음
	- 데이터 중복, 코드 중복은 조직의 사이즈가 커지면 어쩔수 없을 수 있음.
- 바운디드 컨텍스트
	- 특정한 도메인 모델이 적용되는 범위
	- 같은 바운디드 컨텍스트 안에서 도메인 모델의 통합성을 유지
	- 서로 다른 바운디드 컨텍스트 사이에서는 통합성에 신경쓰지 않는다.
	- DDD에서 바운디드 컨텍스트는 논리적으로 나눈다.
- 컨텍스트 맵 context map
	- 컨텍스트 사이의 관계와 모델 변환 방식 정의
- 바운디드 컨텍스트는 조직 관리와 설계가 만나는 곳
- 전략적 디스틸레이션
	- 서브 도메인의 우선순위 매기기
	- 리소스를 어떻게 결정할 것인가?
	- 코어 서브 도메인 > 제네릭 서브 도메인(타사와 비슷하게 해도됨, 기성 소프트웨어, 주니어 개발자 배정 등) > 지원 서브도메인(외주, 개발자 성장을 위한 기회)
	- 코어 서브 도메인은 바뀔 수도 있다.
- 
![[Pasted image 20240825165223.png]]

## 도메인 주도 설계 그 후
- 전략적 패턴
	- 문제 공간
	- 솔루션 공간
- 전술적 패턴
- **참고**
	- 도메인 주도 설계 구현 by 반 버논
![[Pasted image 20240825165611.png]]
- 문제공간 = 도메인
- 솔루션 공간 = 바운디드 컨텍스트
- 어떻게 DDD를 구현하면 되는데?
	- 지금의 DDD책에서 많이 다루는 내용
	- domain event
	- 다시 도메인 이벤트 domain event...
	- -> DDD reference 참고
- 이벤트 소싱 event sourcing
	- 이벤트 스토어에 모두 다남김
	- 재생하면 애그리케이트
	- event sourcing 책
	- command 모델이 필수여야함.
- 하나의 모델을 두 개의 모델로 분리 CQRS
![[Pasted image 20240825170831.png]]

- MSA의 유행
	- 2012
	- 시스템을 각서비스로 나눠서 물리적으로 연동되도록 함.
	- 배포를 따로 나눔.
	- 데이터베이스 분리해야함.
	- 객체의 집합을 나눔.
- 헥사고날 아키텍처의 재조명
	- 2005
	- 연동이 많아지며, 다른 시스템에서 사용자처럼 기능을 요청하게 됨.
	- 대칭적으로 설계하여야 함
	- 유지보수를 잘 하는 것이 목적
- 도메인 주도 설계의 재조명
	- 바운디드 컨텍스트의 개념이 뜨면서 재조명됨
- 구현관점에서 DDD를 보려면 추천 도서
	- ![[Pasted image 20240825171815.png]]
- ![[Pasted image 20240825171836.png]]

![[Pasted image 20240825171905.png]]

---
## 질의 응답
- 논리적으로 나누는 것을 어떻게 구현하는가?
	- 패키지를 피처 기반으로 나눠야한다.
	- 멀티모듈로 나누면 최소한 디펜던시는 전제할 수 있다는 뜻.
	- 만약 이것이 계속 안되면 물리적으로 뜯게됨.
- 서버와 앱이 모델을 다르게 가져가도 되는가?
	- DDD 는 조회용이 아님. 수정의 영역이 아님.
- 바운디드 컨텍스트 네이밍이 어려운 경우가 있다.
	- 기본적으로 사람들이 쓰는 용어와 통일하는 것이 좋다.
- msa를 나눌 때 바운디드 컨텍스트로 나뉘는지?
	- 나누는 기준을 이상적으로 잘 나눠가질 수 있는지?
	- 이상적으로 나누는 것이 굉장히 어려움.
	- 조직 팀의 역할을 따라가게 됨.
- DDD는 도메인에 대한 학습을 전제로 한다.
- 개발이 다른 팀의 용어를 가져오는 것은 자연스럽다.
	- 기획의 변경을 빨리 반영하는 것이 개발자들의 일임.
	- 리팩토링을 빨리하기 위해 노력하자.
- 유비쿼터스 랭귀지
	- 자주 쓰는 언어라는 뜻임.
	- 서로의 언어를 쓰자
	- 협업을 자주 하는 상황일 때.
	- 언어를 굳이 정의하지 않아도... 그때그때 통일하자.
	- 실제로는 커뮤니케이션, 협업에 대한 이야기임.
- 도메인의 그루핑
	- 사업적인 관점에서 그루핑이 중요할 수 있으나
	- 리프 도메인이 더 의미있지 않나?
- 컨텍스트 매핑
	- 산출물이라고 생각할 것인가?
	- 팀간의 협업에 대해서 컨텍스트맵이 정해진다면 이것이 전사적인 차원에서 갈것인가? 이건 선택의 문제
	- 현실적으로 팀간의 약속을 하는 것이 나을듯.

---
## Part2. DDD에서의 기능 구현
- 기능 요구사항과 불변식을 Aggregate로 구현한다.

## Entity 와 Value object
### Entity
- 식별이 필요할 경우
- ID가 있음

### Value object
- 값자체가 중요한 경우

### Data
- 불완전함에도 데이터를 만들 수 있다.
- data -> entity | vo

### 불변객체로 만드는 이유
- 프로그램을 이해하기 쉬움

### 값객체로 복잡성 낮추기
- 엔티티의 복잡성을 낮추기 위한 방법
- 값객체를 사용할 경우
	- entity가 짧아지고 간결해진다.
	- entity의 코드를 읽을 때 일부 불변객체 안으로 들어가므로 어디까지 변화하게 될지 예측이 편해진다.
- 리팩토링하며 자연스럽게 값객체가 나온다.
	- 이름을 짓는 것이 매우 중요 -> 그래야 내부에서 어떤 것을 하는지 알기 휘움

## 연관관계와 애그리게이트
- DDD에서는 기능 요구사항은 책임 주도 설계로 구현
- 책임 주도 설계 RDD
	- 기능 요구사항
- 계약에 의한 설계 DBC
	- 불변식
		- 언제나 일관되게 유지되어야 하는 비즈니스 규칙
		- 불변식은 트랜잭션 일관성 Transactional Consistency와 관련
- DDD 에서의 기능 구현
	- 기능 요구사항과 불변식을 애그리게이트로 구현

### 애그리게이트 Aggregate
- 문제는 모델에 경계가 정의되어 있지 않다는 데 있다.
- 모델 내의 참조에 대한 캡슐화를 추상화시킬 필요가 있다.
- DDD에서 애그리게이트 경계는 요구사항을 분석하여 잘 찾아야 합니다. (어렵...)
- Root 캡슐화의 경계 boundary
	- 이는 entity이다.

### 전역 식별성 & 지역 식별성
- 외부에서 접근 가능한 것은 전역 식별 유니크성을 가져야함.
- 지역 식별성은 애그리게이트 내부에서만 식별성을 가지면 됨.

### 설계의 목적
- 유지보수에 용이해야함.
- 뭔가 바뀌었을 때 해당 부분만 테스트하면 전체에 문제가 없어야함.

### 결합도를 낮추고 싶은 이유
- A가 바뀔 때 B를 바꾸고 싶지 않아함.
- 애그리게이트 내부의 경우, 어차피 같이 바뀌어야 하기 때문에 이 내부에서 결합도, 의존성을 굳이 끊을 필요는 없다. 어차피 같이 바뀌니까.
- 물론, 애그리게이트 외부와는 끊어줘야함.

### 경계를 어떻게 잡는가?
- 불변식을 기준으로 애그리게이트 경계 정의

## 리포지토리
- 애그리게이트를 저장하거나 조회하는 단위
- DDD에서 말하는 리포지토리
	- 메모리에 한꺼번에 이 객체가 모두 다 있다고 착각을 불러 일으키는 객체를 만들 것.
	- 데이터 저장소에 데이터를 추가하고 데이터 저장소에서 제거하는 연산을 캡슐화 하게 하라.
- 애그리게이트 단위로 리포지토리 추가
- 리포지토리를 이해하기 위해서는 연관관계의 개념과 활용 방법 이해 필요
- 초반에는 이 경계를 미리 잡기 힘들 수 있음.
	- 도메인이 어느정도 안정된 다음에 이 범주를 정의하는 것이 필요하다.
- 불변식의 경계를 찾는 것은 원래 어려움.
	- 초반부터 이에 대해 집착할 필요는 없다.

## 연관관계
- A객체가 있으면 이를 통해서 B 객체에 접근할 수 있음.
	- 탐색 가능하다.
- 연관관계 단순화하기
	- 탐색 방향 부여 (양방향 / **단방향**)
	- 한정자를 추가하여 다중성 줄이기
	- 중요하지 않은 연관관계 삭제
- 불필요한 연관관계 제거하기
	- lazy loading을 위해서 연관관계를 갖는다고 하면 이를 제거하는 것이 좋다.
	- DDD의 aggregate는 수정 관계이다. 조회와 이를 섞으면 더 복잡해진다.
		- 이게 너무 복잡해지면 CQRS로 가야함.

### 연관관계를 맺는 방식
- 강한 결합도
	- 직접 참조하고 있음.
- 약한 결합도
	- ID를 참조하고 있음.
	- repository
		- 연관관계를 구현하는 용도로도 사용함.
	- aggregate 사이에는 ID를 넣고 repository 를 통해가져옴.
![[Pasted image 20240901162338.png]]

## Aggregate
- 루트 entity는 전역 식별성을 가지며 궁극적으로 불변식을 검사할 책임이 있다.
- 경계 안의 Entity는 지역식별성을 지닌다. 이러한 지역식별성은 해당 Aggregate안에서만 유니크하면된다.
- aggregate의 경계 밖에서는 루트 entity를 제외한 aggregate 내부 구성 요소를 참조할 수 없다.
- 데이터베이스 질의를 이용하면 aggregate 루트만을 직접적으로 획득할 수 있다.
- 삭제 연산 시 aggregate의 경계안의 모든 요소를 한번에 제거해야 한다.
- aggregate 경계 안의 어떤 객체를 변경하더라도 전체 aggregate의 불변식은 모두 충족되어야 한다.
- 질의응답
	- aggregate 내 외부를 유지하는 방법이 있나?
		- 코드상으로 표현할 것. 외부는 무조건 id를 참조
	- JPA를 기준으로 aggregate를 끊는 방법?
		- DB에는 FK가 있을 수 있으나, 코드 상으로는 FK를 안갖게 할 수 있음.
	- 뎁스와 애그리게이트 경계
		- 애그리게이트 변경 단위는 작을 수록 좋지만 만약 영향을 받는다면 뎁스에 연연할 필요는 없다.
		- 중요한 것은 도메인 룰이 어떻게 되는가가 가장 중요하다.
	- UI를 Aggregate의 경계로 봐서는 안된다.
		- DDD는 command에만 해당된다.
	- 이벤트 소싱
		- 이벤트를 모두 저장해둠. 이벤트를 모두 쌓아서 도메인을 만듬.
		- 이는 조회쪽에서 절대 사용할 수 없음.

## 애그리게이트 경계 정하기
![[Pasted image 20240901165040.png]]
![](https://i.imgur.com/NC8528R.png)

- 불변식으로 aggregate 만들기
- 루트 정하기
	- 루트가 모든 로직들을 처리해야합니다.
- entity와 vo 객체 정하기
	- 어차피 외부에서 찾는 루트는 root임.
- 연관 관계 방향 정하기
	- 내부 연관관계 방향
	- 외부 aggregate와 관계 정하기
	- forwarding delegation 에 주의할 것
- 불변식의 변화가 있는경우
	- 도메인 룰이 달라질 경우
	- 달라지는 애그리게이트 경계
	- 도메인 룰을 만족하는 '최소 경계'
	- 룰이 너무 과하다면 묶어서 할 수밖에 없음.. 무방.
		- 실용적인 측면을 잘 고려해야함.
- 암시적인 결합도가 있음

## 애그리게이트 구현하기
- 애그리게이트 루트 베이스 클래스
	- 가급적이면 lazy loading을 하지 말자.
![](https://i.imgur.com/1TvWnuO.png)
- validation을 aggregate 내부에서 모두 하기 때문에 굉장히 더러워짐.
	- 그래서 잘 뜯어내야한다. (리팩토링)
	- 필요하면 내부 entity에 명령을 요청함.
- entity, vo 구현 방법은 내 맘..!
	- entity의 수정
		- id로 식별 후 수정
	- vo의 수정
		- 삭제 후 다시 삽입 (불변이므로!)
	- 수정보다 삭제가 더 유리할 수도 있으니까 잘 선택하자. 개발하기 편한 방식으로 선택하면 된다.
	- 무언가 entity, vo를 구현하기로 적용하였다면 일관성있게 적용해야한다. (헷갈림...)
- 값 객체 컬렉션 데이터베이스 매핑
	- 1:N 일때는 무조건 다른 데이터 테이블로 분리해야함.
	- ![](https://i.imgur.com/xNEqRwM.png)
	- PK를 모두 묶어서 해야함.
- orm 예시
	- ![](https://i.imgur.com/nEO2fgK.png)
	- (위) JPA entity와 DDD entity를 같게 구현한 예시
	- 침투적인지 구분할때?
		- 단위 테스트를 할 수 있다면 침투적이지 않다고 봐야함.
		- JPA entity의 경우 메모리상에서 실행이 가능하다. 그러나 lazy loading 등이 있다면 DB도 신경써야함. (최대한 쓰지 말자.)
	- (하위) 다르게 구현한 예시
		- ORM entity와 DDD entity가 동시에 바뀌어야 하므로 힘들 수 있음.
		- 선호의 영역임.
		- 만약 여러 조직이 하나의 DB를 쓴다면 원하는 모델을 만들 수 없으므로 아래와 같이 구현하기도 함.

## 리포지토리 구현하기
-  spring data JPA를 이용한 repository 구현
- 만약 JPA에 의존하는 것이 싫다면?
	- 인터페이스 생성 후, JPA repository 구현
	- 근데 기술적인 메리트가 딱히 없는 거 같음.
![](https://i.imgur.com/ujZ0sZ8.png)

## 팩토리와 서비스
### 팩토리
-  어떤 객체나 전체 Aggregate를 생성하는 일이 복잡해 지거나 내부 구조를 너무 많이 드러내는 경우 캡슐화
- 객체를 `new` 하는 것이 결합도가 가장 강하기 때문에 하나의 클래스에 몰빵하는 것이 유리함. -> 스프링 컨테이너, 팩토리...
- 팩토리 사용하지 않을 경우
	- ![](https://i.imgur.com/UyJw351.png)
	- ![](https://i.imgur.com/O8UO1MN.png)
- 팩토리를 사용하여 의존성 관리
	- ![](https://i.imgur.com/dz7RNXt.png)

### 서비스
- 어떠한 객체에도 속하지 않는 연산
- 상태를 갖지 않아야 한다.
- 도메인 모델의 외적 요소의 측면으로 정의된다.
- 연산이 원래부터 도메인 개념과 관련이 있다.
- 도메인 로직
	- 상태가 없는 행위로 모델링할 때 만들어주는 것이 좋음.
	- DB, 컴퓨터 환경 등 벤더를 제외하고 구현하는 것 = 도메인 로직
- 애플리케이션 로직
	- DB에서 뭔가 읽고, 업데이트하거나 메일을 보내거나... = 애플리케이션 로직
![](https://i.imgur.com/c6qCb2i.png)
- DDD의 기본 도메인 로직 구현을 격리하는 것.
	- 가끔 외부로 유출되는 경우가 있음. 로직이 누수...
	- domain 서비스를 만들어서 위치하는 경우도 있음.
	- validation, aggregate 상태 전환하고 싶을 때 도메인 서비스를 만들기도함.
	- 계층간의 관계를 조율하고 싶은 경우...
	- 하지만 강박관념을 가질 필요는 없음. 만약 좀 반복되면 그때 같이 수정하는 방법도 있음.
	- ![](https://i.imgur.com/e23LWkN.png)

## 기타
- 여러 애그리게이트를 수정해야 하는 경우
	- 이벤트 처리
	- 배치 처리
	- 혹은 다른 갱신 매커니즘
- 도메인 이벤트
	- ![](https://i.imgur.com/lAtYHhr.png)
- 우아한 객체지향
	- https://www.youtube.com/watch?v=dJ5C4qRqAgA
- spring data JDBC
	- https://spring.io/projects/spring-data-jdbc
- 이벤트 스토밍
	- [https://youtu.be/gihxS6eE1DM](https://youtu.be/gihxS6eE1DM)
	- [https://youtu.be/hUcpv5fdCIk](https://youtu.be/hUcpv5fdCIk)

## 질의응답
- **DDD와 테스트코드의 상관관계는?**
	- DDD를 적용하면 테스트 코드를 짜기 편안함.
	- 도메인 이벤트 발생을 assertion 하여 단위 테스트 하기 편안함.
- **왜 불변적으로 구현해야 하는가? 동시성 문제가 발생하지는 않을까?**
	- 발생할 수 있음. 애그리게이트 사용여부와 무관하게 동시성 이슈가 발생할 수 있음.
	- 애그리게이트를 사용하는 이유는 동시성 이슈때문에 데이터가 어그러지는 것을 방지하는 것임.
- **DDD가 이상적인 방법이어서 설득 어떻게 하는 것이 좋을까?**
	- DDD를 적용하는 것이 목적이 아니었으면 좋겠음.
	- "이것을 하고 싶어요" 라고 했을 때, 왜 적용해야하는지 납득이 되면 OK.
	- 우리팀에 적용했을 때 왜 좋은지 설득할 수 있어야함. 다른 팀의 예시는 무의미함.
	- 그리고 설득하고 싶어하는 사람이 잘 알아야 함.
- **VO를 사용할 때 메모리 이슈는 없는가?**
	- cloud 가 잘 되어서 메모리 이슈는 생각보다 크게 신경쓰지 않아도됨.
		- AWS 비용이 늘어나는 것이 VO 비용은 거의 없음.
- **id를 값객체로 매핑하면 좋은 점**
	- 개인적으로 선호함
	- 참조 오류를 막을 수 있음.
	- 변수 이름이 깔끔해지고 표현력이 좋아짐.
- 전시 도메인 서버들에 DDD 를 적용할 수 있나?
	- 전체적으로 봤을 때는 DDD
	- 기술적으로는 CQRS
	- 내부적으로는 DDD를 적용했다보긴 힘들겠지만 전체적으로 적용되었다고 봐야함.
- 리프 도메인이라고 볼 수 있는 기준이 있는가?
	- 비즈니스 분석의 영역임.
- 

