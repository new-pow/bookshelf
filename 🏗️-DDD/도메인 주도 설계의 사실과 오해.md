# part1. DDD와 객체지향이 어떤 차이가 있는가
- 객체지향
	- 작은 목표를 구현하는 것
	- 코드 배치를 결정하는 것
- DDD
	- 크다
	- 조직적인 이슈까지 감.

## 도메인 주도 설계의 핵심
- 도메인 주도 설계는 복잡한 도메인을 다뤄야 하는 소프트웨어 프로젝트에 박차를 가하는 것을 목표로 삼는 사고 방식이자 우선순위의 모음이다.
- 도메인 Domain 이란?
	- 사용자가 프로그램을 사용하는 주제 영역
	- 어디까지 구현할 것인가? 범위 자르기
- 모델 이란?
	- 대상의 단순화
	- 수준 자르기
	- 왜 모델을 만들어야하는가? 여러 사람이랑 같이 눈높이view를 맞추기 위하여
- 도메인 모델 domain model
	- 사용자가 프로그램을 사용하는 주제 영역 안에서 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 세부사항은 생략한다.
	- DDD맥락에서 도메인 모델은 코드와 같다고 생각하면 된다.
- 모델 주도 설계 model-driven design
	- 모델과 핵심 설계는 서로 영향을 주며 반복을 통해 구체화된다
- 유비쿼터스 언어 ubiquitous language
	- 모델은 모든 팀 구성원들이 사용하는 언어의 중추
- 원래 DDD의 본질...
![[Pasted image 20240825144131.png]]
- 이렇게 하는 이유?
	- 이상적인 무엇인가를 만드는 것 X
	- 유지보수에 용이하기 위해서
		- 수정할 코드를 잘 찾는다 -> 사업에서 말하는 용어그대로 코드를 찾을 수 있다.
		- 사이드 이펙트가 적게 간다
		- ![[Pasted image 20240825144505.png]]
- 따라서 어떤 언어나 어떤 프로그래밍 패러다임을 전제하지 않습니다.
	- 그러나 DDD가 등장했던 2003년 상황에서는...
		- 객체지향, 애자일이 굉장히 떠오르고 있었다. -> 도메인 주도 설계의 개념적 바탕이 되었다.

## 객체지향 설계에서 도메인 주도 설계로
- 객체가 흥해진 이유?
	- GUI 때문
		- UI에서는 객체지향이다.
		- 상태가 있고, 메시지를 준다.
- 웹의 부상
	- 브라우저 성능이 떨어지자 애플리케이션 태어로 객체의 도메인 로직을 넘긴다.
	- ![[Pasted image 20240825145543.png]]
- 분산 객체 기술의 유행
	- EJB 컨테이너
	- 침투적인 아키텍처
		- 컨테이너의 기술 적인 지원을 받기 위해 EJB가 강요하는 인터페이스나 추상클래스 상속해야함
		- 비판 : 관심사 분리가 안된다. 서로 다른 이유로 바뀌는 것들을 뭉쳐놓으므로 변경가능성이 2배. 고려해야할 문제도 2배가 된다.
- POJO
	- plan old java object
	- 인프라에 의존성을 없애는 것.
	- spring 이 관심사를 분리할 수 있도록 도와줄게 :)
- 90년대에 기술에 대한 주목도가 컸기 때문에 이런 논의가 진행되었다.
- 도메인 주도 설계 출간
	- 기술적인 것을 제외하고 사고방식으로 나온 것이 DDD
- 분산 객체 기술의 문제점
	- 표현적 차이
		- 도메인에 대한 멘탈 모델과 소프트웨어 내부에 표현도니 도메인 개념 사이의 거리
		- 모델 주도 설계
	- 침투적인 기술로 인한 커뮤니케이션의 복잡성
		- 
	- 유비쿼터스 언어
# 모델주도설계의 빌딩 블록
## 도메인 로직의 격리
- 도메인 주도 설계의 전제 조건은 도메인 구현을 격리하는 것
- 레이어 아키텍처는 예시
## 모델 주도 설계의 빌딩 블록
- 구현 가능한 도메인 모델을 구성하는 요소들의 목록
- 가이드라인 빌딩블록
- 각 구성 요소에는 구현과 관련된 다양한 가정 내포
- 모델과 구현에 관한 의사 결정을 내리기 위해 필요한 용어 제공
- 도메인을 표현하기 위한 빌딩 블록
	- association
	- entity
	- value object
	- service
	- module
- 생명 주기를 관리하기 위한 빌딩 블록
	- aggregate
	- repository
	- factory
- 구현에 대한 가이드를 제공해서 복잡도를 낮추는 것
- 불변식 invariant
	- 항상 true여야 되는 식
	- 데이터 중심의 관점으로는 이 불변식이 깨질 수 있다.
	- -> aggregate 로 해결할 수 있음
## aggregate
- 불변식 (도메인의 룰)에 따름
- 트랜잭션의 단위
	- aggregate 단위로 트랜잭션 처리하면 됨.
- 저장 단위
- ![[Pasted image 20240825154313.png]]

### 참고자료
- 엔터프라이즈 애플리케이션 아키텍처 패턴
	- 도메인 모델 (패턴)
	- 트랜잭션 스크립트
	- 액티브 레코드 등의 용어 참고하기 좋음
- 트랜잭션 스크립트
	- 도메인 레이어
	- 메서드 하나에 스크립트 작성
	- 스크립트가 트랜잭션 단위로 작성됨. (트랜잭션 시작 - 로직 - 업데이트 - 트랜잭션 종료)
![[Pasted image 20240825154640.png]]

# 애자일과 도메인 주도 설계
- 애자일에서의 핵심
	- 코드레벨에서는 **리팩토링**
- 리팩터링
	- 소프트웨어의 겉보기 동작은 그대로 유지한 채 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 모델 주도 설계 Model driven design
	- 도메인 모델 변경 -> 코드 변경
![[Pasted image 20240825160744.png]]
- 완벽한 도메인을 처음부터 만들지 말자.
	- 점점 개선
![[Pasted image 20240825161410.png]]

# 전략적 설계
- 개발과 정치가 만나는 곳
- 시스템에서 도메인 모델은 여러개여야 한다.
- 응집도가 낮은 코드
	- SRP
	- 여러 사람이 함께 고치는 경우
- 코드 중복?
	- 나는 것이 나쁘지 않을 수 있음
	- 데이터 중복, 코드 중복은 조직의 사이즈가 커지면 어쩔수 없을 수 있음.
- 바운디드 컨텍스트
	- 특정한 도메인 모델이 적용되는 범위
	- 같은 바운디드 컨텍스트 안에서 도메인 모델의 통합성을 유지
	- 서로 다른 바운디드 컨텍스트 사이에서는 통합성에 신경쓰지 않는다.
	- DDD에서 바운디드 컨텍스트는 논리적으로 나눈다.
- 컨텍스트 맵 context map
	- 컨텍스트 사이의 관계와 모델 변환 방식 정의
- 바운디드 컨텍스트는 조직 관리와 설계가 만나는 곳
- 전략적 디스틸레이션
	- 서브 도메인의 우선순위 매기기
	- 리소스를 어떻게 결정할 것인가?
	- 코어 서브 도메인 > 제네릭 서브 도메인(타사와 비슷하게 해도됨, 기성 소프트웨어, 주니어 개발자 배정 등) > 지원 서브도메인(외주, 개발자 성장을 위한 기회)
	- 코어 서브 도메인은 바뀔 수도 있다.
- 
![[Pasted image 20240825165223.png]]

# 도메인 주도 설계 그 후
- 전략적 패턴
	- 문제 공간
	- 솔루션 공간
- 전술적 패턴
- **참고**
	- 도메인 주도 설계 구현 by 반 버논
![[Pasted image 20240825165611.png]]
- 문제공간 = 도메인
- 솔루션 공간 = 바운디드 컨텍스트
- 어떻게 DDD를 구현하면 되는데?
	- 지금의 DDD책에서 많이 다루는 내용
	- domain event
	- 다시 도메인 이벤트 domain event...
	- -> DDD reference 참고
- 이벤트 소싱 event sourcing
	- 이벤트 스토어에 모두 다남김
	- 재생하면 애그리케이트
	- event sourcing 책
	- command 모델이 필수여야함.
- 하나의 모델을 두 개의 모델로 분리 CQRS
![[Pasted image 20240825170831.png]]

- MSA의 유행
	- 2012
	- 시스템을 각서비스로 나눠서 물리적으로 연동되도록 함.
	- 배포를 따로 나눔.
	- 데이터베이스 분리해야함.
	- 객체의 집합을 나눔.
- 헥사고날 아키텍처의 재조명
	- 2005
	- 연동이 많아지며, 다른 시스템에서 사용자처럼 기능을 요청하게 됨.
	- 대칭적으로 설계하여야 함
	- 유지보수를 잘 하는 것이 목적
- 도메인 주도 설계의 재조명
	- 바운디드 컨텍스트의 개념이 뜨면서 재조명됨
- 구현관점에서 DDD를 보려면 추천 도서
	- ![[Pasted image 20240825171815.png]]
- ![[Pasted image 20240825171836.png]]

![[Pasted image 20240825171905.png]]

---
# 질의 응답
- 논리적으로 나누는 것을 어떻게 구현하는가?
	- 패키지를 피처 기반으로 나눠야한다.
	- 멀티모듈로 나누면 최소한 디펜던시는 전제할 수 있다는 뜻.
	- 만약 이것이 계속 안되면 물리적으로 뜯게됨.
- 서버와 앱이 모델을 다르게 가져가도 되는가?
	- DDD 는 조회용이 아님. 수정의 영역이 아님.
- 바운디드 컨텍스트 네이밍이 어려운 경우가 있다.
	- 기본적으로 사람들이 쓰는 용어와 통일하는 것이 좋다.
- msa를 나눌 때 바운디드 컨텍스트로 나뉘는지?
	- 나누는 기준을 이상적으로 잘 나눠가질 수 있는지?
	- 이상적으로 나누는 것이 굉장히 어려움.
	- 조직 팀의 역할을 따라가게 됨.
- DDD는 도메인에 대한 학습을 전제로 한다.
- 개발이 다른 팀의 용어를 가져오는 것은 자연스럽다.
	- 기획의 변경을 빨리 반영하는 것이 개발자들의 일임.
	- 리팩토링을 빨리하기 위해 노력하자.
- 유비쿼터스 랭귀지
	- 자주 쓰는 언어라는 뜻임.
	- 서로의 언어를 쓰자
	- 협업을 자주 하는 상황일 때.
	- 언어를 굳이 정의하지 않아도... 그때그때 통일하자.
	- 실제로는 커뮤니케이션, 협업에 대한 이야기임.
- 도메인의 그루핑
	- 사업적인 관점에서 그루핑이 중요할 수 있으나
	- 리프 도메인이 더 의미있지 않나?
- 컨텍스트 매핑
	- 산출물이라고 생각할 것인가?
	- 팀간의 협업에 대해서 컨텍스트맵이 정해진다면 이것이 전사적인 차원에서 갈것인가? 이건 선택의 문제
	- 현실적으로 팀간의 약속을 하는 것이 나을듯.