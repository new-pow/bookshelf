# 4. 아키텍처
## 4.1 MySQL 엔진 아키텍처
![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F1feb7462-9c33-4bf1-b0bb-7973d34ffaf2%2F084031f1-99f4-41c0-8810-97f871f28ac1%2FUntitled.png?table=block&id=cad2f53f-6bf6-4ae7-8bc6-fd2db018dc6f&spaceId=1feb7462-9c33-4bf1-b0bb-7973d34ffaf2&width=2000&userId=180a704c-6552-4796-9dd2-ab125439ed98&cache=v2)
- 크게 **MySQL 엔진**과 **스토리지 엔진**으로 구분합니다.
- 이 둘을 합쳐 MySQL 혹은 MySQL 서버라고 표현합니다.

### 4.1.1.1 MySQL 엔진

- 클라이언트로부터 접속 및 쿼리 요청을 처리하는 **커넥션 핸들러**
- SQL 파서
- 전처리기
- 옵티마이저
- 표준 SQL(ANSI SQL) 문법을 지원하기 때문에 표준 문법에 따라 작성된 쿼리를 다른 DBMS와 호환할 수 있습니다.

### 4.1.1.2 스토리지 엔진

- 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 전담합니다.
- MySQL 엔진과 달리 스토리지 엔진은 여러개 사용할 수 있습니다.
- 테이블 생성시 같이 사용할 엔진을 지정할 경우, 해당 스토리지 엔진이 처리합니다.

### 4.1.1.3 핸들러 API

- MySQL엔진이 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러 요청이라고 합니다.
- 이에 사용되는 API를 핸들러 API라고 합니다.
- _MySQL 엔진이 스토리지 엔진에게 데이터를 요처앟고 받는 API_


## 4.1.2 MySQL 스레딩 구조
![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F1feb7462-9c33-4bf1-b0bb-7973d34ffaf2%2F0ec12c3c-7287-444a-ab5e-4e68e6f40278%2FUntitled.png?table=block&id=cbd181ce-fd12-43f3-b207-b088c7073dab&spaceId=1feb7462-9c33-4bf1-b0bb-7973d34ffaf2&width=2000&userId=180a704c-6552-4796-9dd2-ab125439ed98&cache=v2)
- 80 페이지 MySQL 스레딩 모델

- MySQL 서버는 스레드 기반으로 작동합니다.
- 포그라운드 스레드와 백그라운드 스레드가 있습니다.

<aside> 🤔 추후에 다룰 것

- MySQL 엔터프라이즈 에디션에서는 전통적인스레드 모델 뿐 아니라 스레드 풀 모델을 사용하고 있습니다. 하나의 스레드가 여러 개의 커넥션 요청을 전담합니다. </aside>

### 4.1.2.1 포그라운드 스레드 (클라이언트 스레드)

- MySQL 서버에 접속된 클라이언트의 수만큼 최소 존재합니다.
- 주로 사용자가 요청하는 쿼리 문장을 처리합니다.
- 사용자가 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아갑니다.
    - thread_cache_size 에 따라 이미 스레드 캐시에 일정 이상 있다면 그냥 스레드를 종료합니다.
- 데이터 버퍼나 캐시로부터 데이터를 가져오며 만약 데이터가 없는 경우,직접 데이터파일이나 인덱스 파일로부터 데이터를 읽어와서 처리합니다.

### 4.1.2.2 백그라운드 스레드

InnoDB에서만 존재합니다.

- 수행하는 작업
    - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
    - **로그를 디스크로 기록하는 스레드**
    - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
    - 데이터를 버퍼로 읽어오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드

InnoDB에서 쓰기작업은 버퍼링되어 일괄 처리하지만, MyISAM은 사용자 스레드가 쓰기 작업까지 처리하도록 되어 있습니다.

읽기 작업은 절대로 지연되지 않습니다.

<aside> 🤔 그럼 포그라운드 스레드는 디스크에 저장되기 전에 버퍼에서 데이터를 읽기를 시도하는 건가요?

왜 데이터를 버퍼로 읽어오는 스레드가 백그라운드에 따로 있는 건가요?

</aside>

## 4.1.3 메모리 할당 및 사용 구조

- 글로벌 메모리 영역과 로컬 메모리 영역이 있습니다.

### 4.1.3.1 글로벌 메모리 영역

글로벌 메모리 영역의 경우 MySQL 서버가 시작되면서 운영체제로부터 할당됩니다.

모든 스레드에 의해 공유됩니다.

(이미지랑 왜 다르지??? 이미지가 잘못된건가;)

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 4.1.3.2 로컬 메모리 영역

세션 메모리 영역이라고도 합니다.

MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역입니다.

각 클라이언트 스레드별로 독립적으로 할당되어 절대 공유되어 사용되지 않습니다.

- 커넥션이 열려잇는동안 계속 할당된 생태로 남아있는 공간 (커넥션 버퍼나 결과 버퍼)
- 실행하는 순간에만 할당했다가 해제하는 공간 (소트 버퍼나 조인 버퍼)
