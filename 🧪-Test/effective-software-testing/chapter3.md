# 구조적 테스트와 코드 커버리지
- 명세 기반 테스트 -> 소스 코드를 활용해 테스트 스위트를 확장한다.
- 구조적 테스트
	- 소스 코드의 구조를 사용하여 테스트를 도출하는 것

## 3.1 코드 커버리지, 올바른 방법
## 3.2 구조적 테스트 간략히 살펴보기
- 명세 기반 테스트
- 프로세스 (필요한 구간 반복)
	- 구현 사항 읽고 개발자의 주요 결정사항을 이해하기
	- 고안했던 테스트 ㄱ케이스를 코드 커버리지 도구로 수행(체크)
	- 테스트가 수행되지 않은 코드에 대해
		- 왜 수행되지 않았는지 이해
		- 테스트할 가치가 있는지 결정
		- 자동화된 테스트 케이스를 구현
	- 다른 흥미로운 테스트 찾아보기
## 3.3 코드 커버리지 기준
- 코드 줄 커버리지
- 분기 커버리지
- 조건 + 분기 커버리지
	- 각 조건을 true|false 로 만족하도록 하는 ㅔㅌ스트를 적어도 하나 만들 것
	- 그리고 전체 분기문을 true|false 로 만족하는 테스트를 적어도 하나 만들 것
	- 모든 경우의 수를 고려하지 않아도됨
- 경로 커버리지
	- 프로그램이 수행할 수 있는 모든 실행경로를 수행
- 복잡한 조건과 MC/DC 커버리지 기준
	- 가능한 모든 조건을 테스트 하는 대신 테스트가 필요한 중요한 조합을 찾아낸다
	- 필요한 테스트 개수가 N+1 이다
	- 결국 결과에 독립적으로 영향을 미치는가, 가 중요
- 반복문과 유사 구조 처리
	- 경계를 고려하여 반복문 테스트가 여러개 생길수도 잇음
	- 보통은 0, 1, 여러번 으로 나눔
## 3.6 기준 포함과 선택
- 기준간의 트레이드오프가 필요함
- 취약한 기준은 비용이 적고 빠르게 수행할 수 있지만, 코드가 수행하지 않는 부분을 남기게 됨
- 탄탄한 기준은 비용을 많이 들여서 더 엄격하게 코드를 수행할 수 있도록 개발함
## 3.8 경계 테스트와 구조적 테스트
- 명세 기반 테스트의 가장 어려운 부분은 경계를 찾는 일인데, ㄱ여계는 소스 코드에서 훨씬 찾기 쉽다.
- ? TDD 를 하게 되면 구조적 테스트를 못하는가?
	- 미리 설계가 되어있어야 하지 않는가?
## 3.9 구조적 테스트만 적용하는 것은 충분하지 않다.
- 특이 케이스는 주로 커버리지로 유도되는 순수한 구조적 테스트에서는 얻을 수 없다.
- 명세에 대한 지식을 더했을 때 그 가치를 드러낸다.
## 3.10 현업에서의 구조적 테스트
- 왜 코드 커버리지를 싫어하는 것일까?
	- 구조적 테스트와 코드 커버리지를 사용하는 방법
		- 명세 기반 테스트를 강화하고, 테스트 스위트가 현재 수행하지 않는 코드 부분을 재빨리 찾아내며 명세 기반 테스트를 수행할 때 놓쳤던 구획을 찾을 수 있을 것이다.
	- 반드시 코드 커버리지를 높일 필요는 없지만, 코드 커버리지가 매우 낮다는 것은 시스템이 제대로 테스트되지 않았다는 증거가 될 수 있다.
- 작가는 어떤 기준을 선호하는가?
	- 얼마아 엄격하고 싶은지, 무엇을 테스트 하는지에 따라 다름.
	- 명세 기반 테스트를 보완하기 위한것이므로 수행하지 않은 부분을 찾을 때 코드 커버리지 적용
	- 분기 커버리지와 조건+분기 커버리지, MC/DC 를 복합적으로 사용하는 것을 선호
- 무엇을 수행하지 말아야 하나?
	- 커버리지 100 달성? 불가능
	- equal, hash, getter, setter 테스트
	- 예외가 발생하는 것보다 그 외 나머지에서 어떤 일이 일어나는지가 더 중요하다
## 3.11 돌연변이 테스트
- 존재하는 코드에 일부러 버그를 주입해서 테스트 스위트가 깨지는지 검사
- 테스트를 테스트함
- 가정
	- 유능한 프로그래머 가설
		- 유능한 프로그래머가 작성한 프로그램은 그 구현 버전이 올바르거나 단순 오류의 조합으로 정확한 프로그램이 된다는 가정
	- 커플링 효과
		- 복잡한 버그는 작은 버그들이 모여 발상한다는 가정. 테스트 스위트가 작은 버글르 잡을 수 있으면 더 복잡한 것도 잡을 수 있음
- 돌연변이 테스트를 실행하기 위한 도구
	- 파이테스트
- 돌연변이 테스트 도구는 코드를 알지 못한다. 다만 커버리지와 같은 도구로 바라보아야 한다.
- 시스템에서 좀 더 민감한 부분에 대해 돌연변이 테스트를 적용해보자.

