---
tags:
  - architecture
  - ddd
---
# 📕 도메인 주도 개발 시작하기
- 읽은 기간 : 2026. 01. 19 ~ 
---
# 1. 도메인 모델 시작하기
## 도메인이란?
- 도메인은 소프트웨어로 해결하고자 하는 문제영역을 뜻한다.
	- 개발자 입장에서는 '구현해야 할 소프트웨어의 대상'
- 한 도메인은 다시 하위 도메인으로 나눌 수 있다.
	- 하위 도메인을 어떻게 구성할지 여부는 상황에 따라 다르다.

## 도메인 전문가와 개발자 간 지식 공유
- 코딩에 앞서 요구사항을 올바르게 이해하는 것이 중요하다.
- 요구사항을 제대로 이해하지 않으면 쓸모없거나 유용함이 떨어지는 시스템을 만든다.
	- 오히려 변경/다시 만들기에 일정을 더 쓸 수도 있으므로 주의할 것.
- 도메인 이해도를 높이고, 요구사항을 정확하게 구현하기 위해 **개발자와 전문가가 직접 대화하는 것이 중요**하다.
- ==❓AI 도입 후 도메인 주도 개발의 의의는, 결국 이 '요구사항'과 '유비쿼터스 언어'의 중요성 부각인 것 같다.==

## 도메인 모델
- 기본적으로 특정 도메인을 '개념적'으로 표현한 것.
- 도메인 모델을 객체로만 모델링 할 수 있는 것은 아니다.
	- 상태 다이어그램
	- 클래스 다이어그램
	- 그래프 등등
- ==❓표현 방식은 문서로서 작동할 수 있으면 뭔들?==

> 도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델이다. 개념 모델을 이용해서 바로 코드를 작성할 수 있는 것은 아니기에 구현 기술에 맞는 구현 모델은 따로 필요하다. p.029

- ==💡함수형으로 도메인을 표현한 사례도 있었는데, 다른 곳에도 통용되는지는 모르겠음;==
- 하위 도메인과 모델
	- 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다.
	- 도메인에 따라 용어 의미가 결정되므로 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안된다. (혼란이 있으므로)

## 도메인 모델 패턴
- 도메인 모델은 아키텍처 상의 도메인 계층을 객체 지향기법으로 구현하는 패턴을 말한다.
	- 참고: '엔터프라이즈 애플리케이션 아키텍처 패턴' 마틴 파울러
- 도메인 계층은 도메인의 핵심 규칙을 구현한다.
	- **핵심 규칙을 구현한 코드가 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.** p.33
- 개념모델과 구현 모델
	- 개념 모델 = 순수하게 문제를 분석한 결과물
	- 구현 모델 = 개념 모델을 구현 가능한 형태의 모델로 전환하는 과정을 거침.
	- **처음부터 완벽한 개념 모델을 만들기보다는 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야 한다. 프로젝트 초기에는 개요 수준의 개념 모델로 도메인에 대한 전체 윤곽을 이해하는 데 집중하고, 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다. p.34**

## 도메인 모델 도출
- 문서화
	- 전반적인 기능 목록이나 모듈 구조, 빌드 과정은 코드를 보고 이해하는 것보다 상위 수준에서 정리한 문서를 참조하는 것이 소프트웨어 전반을 빠르게 이해하는 데 도움이 된다.
	- 도메인 관점에서 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지고 문서로서 코드가 의미를 갖는다.

## 엔티티와 밸류
- 엔티티
	- 서로 다른 식별자가 있다. 객체마다 고유하다.
	- ==❓ ID를 DB에서 자동생성하는 경우, ID가 있는 도메인과 없는 도메인을 구별해야할까? (DB 저장 전 도메인과 저장 후 도메인) 어떻게 사용하고 계신지 궁금합니다==
		- 엔티티의 생명주기에 관련한 질문인 것같음.
		- DB 자동 생성하는 ID말고 코드상으로 ID를 생성해준다.
		- 파일은 동일하게 사용하고 있음.
- 밸류
	- 개념적으로 완전한 하나를 표현할 때 사용.
	- 두 밸류 객체를 비교할 때는 모든 속성이 같은지를 비교한다.
- 도메인 모델에 set 메서드는 넣지 않기
	- 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해준다.
	- 불변 밸류 타입을 사용해서 set 메서드를 구현하지 않는다.

## 도메인 용어와 유비쿼터스 언어
- 도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야하는 부담을 준다.
	- 유비쿼터스 언어로 가독성을 높이자.
- 유비쿼터스 언어란, 모든 이해관계자가 같은 용어를 사용하는 것.
	- 소통 과정에서 용어의 모호함을 줄인다.
	- 코드에서 불필요한 해석을 줄일 수 있다.
- 도메인 용어에 알맞는 단어를 찾는 시간을 아까워하지 말자.
- ==💡DDD의 가장 핵심이라 생각==

---
# 2. 아키텍처 개요
- 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역: 표현, 응용, 도메인, 인프라스트럭처
	- 표현Presentation: 사용자 요청을 해석해서 응용 서비스에 전달
	- 응용Service: 시스템이 사용자에게 제공해야 할 기능을 구현
	- 도메인Domain: 도메인 모델을 구현
	- 인프라스트럭처Infrastructure: 실제 구현. 외부 DB 등과 연결
- 계층 구조 아키텍처

```mermaid
flowchart TB
  P[Presentation Layer] --> S[Service Layer]
  S --> D[Domain Layer]
  D --> I[Infrastructure Layer]
```

- 계층 구조는 그 특성상 상위 계층에서 하위계층으로의 의존만 존재.
	- 반대 방향은 의존하지 않는다.
- 전형적인 계층구조상의 의존 관계
```mermaid
flowchart TB
  subgraph Application["응용"]
    S[서비스]
  end

  subgraph Domain["도메인"]
    E[엔티티]
  end

  subgraph Infrastructure["인프라 스트럭처"]
    DB[DB 모듈]
    RULE[룰 엔진]
  end

  %% 의존 관계 (점선)
  S -.-> E
  S -.-> DB
  E -.-> RULE
```
## DIP
- 이를 해결하기 위함이 바로 DIP: 의존성 역전 원칙
	- 인프라스트럭처에 따라 서비스 구현이 의존하게된다.
	- 인프라스트럭처가 바뀌면 서비스도 바뀌어야함.
- 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.
- 추상화한 인터페이스를 사용한다.
	- 룰 적용한 클래스는 인터페이스를 상속받아 구현한다.
	- 인터페이스는 대역객체(mock 객체)를 사용해서 테스트를 진행할 수도 있다.
- 주의사항
	- 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함.
	- 저수준 모듈에서 인터페이스를 추출하지 않도록 한다.

```mermaid
flowchart TB
  subgraph 고수준["고수준"]
    S[서비스]
    I[인터페이스]
  end

  subgraph 저수순["저수준"]
    In[인프라스트럭처]
  end

  %% 의존 관계 (점선)
  S -.-> I
  In -.구현.-> I
```
## 도메인영역의 구성
- 엔티티 Entity
	- 고유한 식별자를 갖는 객체
	- 도메인의 고유한 개념을 표현한다.
	- 데이터를 포함. 데이터와 관련된 기능을 제공.
	- 도메인 기능을 함께 제공. (DB entity 와 구분된 개념으로 사용해야함)
	- 도메인 관점에서 기능을 구현하고, 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.
- 밸류 Value
	- 고유한 식별자를 갖지 않는 객체. 개념적으로 하나인 값을 표현할 때 사용.
- 애그리거트 Aggregate
	- 엔티티와 밸류 객체를 하나로 묶은 개념.
	- OrderAggregate = Order entity + OrderLine value + Orderer value
	- 도메인이 커질수록 엔티티와 밸류 개수가 많아진다. 모델은 점점 복잡해진다. 도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것.
	- 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근한다. -> 애그맅거트를 기준으로 캡슐화
- 리포지터리 Repository
	- 도메인 모델의 영속성을 처리한다.
	- 엔티티 객체를 로딩하거나 저장하는 기능 제공 등
	- 구현을 위한 도메인 모델. 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
- 도메인 서비스 Domain Service
	- 특정 엔티티에 속하지 않은 도메인 로직을 제공한다.
	- 예를 들어, 할인 금액 계산 등.
## 인프라스트럭처 개요
- 구현의 편리함은 DIP 의 장점만큼 중요하므로 트레이드오프를 고려하여 구현하도록한다.

## 모듈 구성
- 패키지 구조

---

# 3. 애그리거트
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 것이 필요하다. -> 애그리거트 의 역할
- 일관성을 관리하는 기준이 된다.
- 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다.
	- 대부분 함께 생성하고 함께 제거
- (글쓴이의 경험에 비추어보면) 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았으며, 두 개 이상의 엔티티로 구성되는 애그리거트는 드물었다. p.102
	- ==?: 한 애그리거트 내에서 ID를 2개 쓰는 경험이 있었는지?==
## 애그리거트 루트
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면, 전체를 관리할 주체가 필요 -> 애그리거트의 루트 엔티티
- 일관성을 유지시켜줘야한다.
- 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만든다.
	- 단순히 필드를 변경하는 set 메서드는 public 으로 만들지 않는다.
	- 밸류 타입은 불변으로 구현한다.
- 애그리거트 루트는 구성요소의 상태 참조한다.
- 애그리거트 루트는 구성요소에게 기능 실행을 위임하기도 한다.
- 트랜잭션 범위는 작을 수록 좋다.
	- 한 개 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것은 성능상 차이가 발생한다.
	- ==스터디 중: 일관성이 깨졌던 경험이 있었음.==
		- 사례 1: Stale Read + Lost Update (MVCC 환경)
		- 사례 2: 락 대기로 인한 중간 상태 노출
		- -> 그래서 나온게 SAGA 패턴
	- ==스터디 중: 트랜잭션을 걸지 말자, 라고 팀 내에서 논의함.==
		- 중간에 뭐가 잘못되었을 때, 롤백하지 않음. 결제만 성공하면 -> 서비스가 돌아가도록함.
- 

> **트랜잭션은 단순한 `BEGIN–COMMIT`이 아니다**
> - 락(lock) 획득 및 유지
> - Undo / Redo 로그 기록
> - MVCC 스냅샷 관리
> - 충돌 감지 및 롤백 대비
> 
> **테이블 수가 늘면 락 범위와 충돌 확률이 증가한다.**
> - 데드락 가능성 증가
> Undo / Redo 로그가 기하급수적으로 늘어난다.
> - DB 트랜잭션은 롤백용 undo log, 장애 복구용 redo log를 기록한다. 트랜잭션이 무거울수록 로그 세트도 증가하고, 디스트 I/O, fsync 비용이 증가한다.
> 
> **MVCC에서 트랜잭션이 길수록 문제가 커진다**
> - Postgresql, MySQL innoDB 기준하여, 긴 트랜잭션은 옛버전을 오래 유지하게 한다.
> - VACUUM 지연, 인덱스 효율 저하 등이 일어난다.
> 
> 자연스럽게 CPU 관점에서도 차이가 난다.

- ==? 그러나 일관성을 유지하려면 트랜잭션을 길게 가지고 싶은 마음도 있지 않을까? 트랜잭션을 짧게 가져가고 매번 보상로직을 추가해주는 것이 더 경제적일까?==
	- 트레이드 오프라고 생각됨.
	- 일종의 기준이 필요하지 않을까?

| 기준                | 트랜잭션/보상로직 |
| ----------------- | --------- |
| 단일 Aggregate인가?   | 트랜잭션 유지   |
| 강한 불변식이 있는가?      | 트랜잭션 유지   |
| 외부 시스템이 포함되는가?    | 트랜잭션 분리   |
| 고트래픽인가?           | 트랜잭션 축소   |
| 장애 복원력이 중요한가?     | 보상/이벤트    |
| 미래에 분리될 가능성이 있는가? | 보상 설계     |
|                   |           |

- 한 트랜잭션에서 한 애그리거트를 수정한다.
- 애그리거트에서 다른 애그리거트를 변경하지 않는다.
	- 자신의 책임 범위를 넘지 않기
- 도메인 이벤트를 사용하여 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다.

## 리포지터리와 애그리거트
- 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재
- 기본으로 애그리거트 저장, 애그리거트 찾기를 제공한다.

## ID를 이용한 애그리거트 참조
- 애그리거트가 다른 애그리거트를 참조할때는 ID를 참조한다.
- 애그리거트를 직접 객체로 참조할때의 문제점
	- 애그리거트의 책임 범위가 흐려진다.
	- 성능과 관련된 고민을 해야한다.
	- 분산 시스템으로 확장하고자 할때, 기존 도메인간 의존도가 높아 어려움이 있다.
- ID로 참조하면 구현 복잡도가 낮아진다.
- ID로 참조시 N+1 조회 문제가 발생할 수 있다.
	- 이런 경우, 조회 전용 쿼리를 사용하면 된다. DAO 조회 메서드에서 조인을 이용해 한번의 쿼리로 필요한 데이터를 로딩
	- 또는 캐시를 적용
	- 또는 조회 전용 저장소를 따로 구성한다.

## 애그리거트 간 집합 연관

## 애그리거트를 팩토리로 사용하기
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야한다면, 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.
	- ex. Store -> Product
- 혹은 다른 팩토리에 위임하는 방법도 있다.
	- ex. Store -> ProductFactory.create() -> Product


---
# 4. 리포지터리와 모델 구현
- ==💡결국은 DDD의 철학을 어떻게 JPA로 구현할 것인가에 대한 챕터==

## JPA를 이용한 리포지터리 구현
## 스프링 데이터 JPA를 이용한 리포지터리 구현
## 매핑구현
- `@Embeddable` 로 매핑
	- 기본생성자를 제공해야한다.
	- 기본생성자는 protected 로 선언하여 공개하지 않는다.
- `AttributeConverter` 
- `@ElementCollection`, `@CollectionTable` 밸류 컬렉션을 별도 테이블로 매핑할 경우
	- `@ElementCollection` 을 사용하면 함께 조인된 테이블의 데이터도 삭제되므로 주의.
- 식별자 자체를 밸류타입으로 만들기 위해서는 `@EmbeddedId` 어노테이션 사용.
	- Serializable 을 상속받아 구현해야 한다.
- 밸류를 매핑한 테이블을 지정하기위해 `@SecondaryTable`, `@AttributeOverride` 사용
	- `@SecondaryTable` : 두 테이블을 join 함.
- 목록을 조회할때는 모든 상세밸류를 가져올 필요가 없다. 조회 전용 기능을 따로 구현하는 방법을 사용하는 것이 좋다.
- 타입에 따라 entity가 달라야하는 경우(책에서 Image 예시)
	- 상위에 `@Inheritance` 어노테이션 `strategy=SINGLE_TABLE`
	- `@DiscriminatorColumn` 애너테이션으로 타입 구분용 컬럼 지정
	- 하위에서는 `@Entity`, `@DiscriminatorValue` 어노테이션을 사용한다.

## 애그리거트 로딩 전략
- 애그리거트에 속한 객체가모두 모여야 완전한 하나가 된다.
- 루트 Entity 를 로드할때 즉시로딩하면 된다.
	- `FetchType.EAGER`
- 컬렉션에 대해 즉시 로딩전략을 사용하면 위험하다.
- 애그리거트는 개념적으로 하나여야하지만, 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야하는 것은 아니다.
- JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에, 실제로 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.
- 표현영역에서 애그리거트 상태 정보를 보여줄 때는, 조회 전용 기능과 모델을 구현하는 방식을 사용한다.
- **애그리거트에 맞게 즉시로딩과 지연 로딩을 선택한다.**

## 애그리거트의 영속성 전파
- 애그리거트에 속한 `@Entity` 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제 시에 함께 처리되도록 설정해야한다.

## 식별자 생성기능

## 도메인 구현과 DIP
- 특정 기술에 의존하지 않는 순수한 도메인 모델을 추가하는 개발자는 JPA에 특화된 어노테이션을 모두 빼고, 인프라 JPA를 연동하기 위한 클래스를 추가한다. (ex. JpaArticle : 이런 클래스에 어노테이션이 모두 있음.)
- 구현 기술을 변경하더라도 도메인이 받는 영향을 최소화할 수 있다.
- 하지만 리포지터리와 도메인 모델의 구현기술은 거의 바뀌지 않는다.
- **DIP를 완벽하게 지키면 좋겠지만, 개발 편의성과 실용성을 가져가면서 구좆거인 유연함은 어느정도 유지하도록한다.**
	- 합리적으로 선택할 것.

## 질문사항
- JPA로 DDD 아키텍처를 구현해보셨는지? 실무에서의 활용도 이와 비슷한지?
	- 실패한 경험을 들음. 도메인객체와 영속성 객체를 분리하면, JPA 가 주는 이점들을 살리기가 힘든 것 같다.
---
# 5. 스프링 데이터 JPA를 이용한 조회 기능
- CQRS : 명령 모델과 조회 모델을 분리하는 패턴
	- 명령 모델은 상태를 변경하는 기능을 구현할 때 사용하고, 조회 모델은 데이터를 조회하는 기능을 구현할 때 사용한다.
- (필자) 조회를 구현할때 다양한 기술을 사용한다.
## 검색을 위한 스펙
- 검색 조건을 다양하게 조합해야할 때 사용할 수 있는 스벡 Specification
- `isSatisfiedBy()` 라는 함수를 사용해서 여러 조건을 함께 조회한다.
	- 리포지토리 -> 애그리거트 루트 조회
	- DAO -> 검색 결과로 리턴할 데이터 객체
- JPA 크리테리아 Criteria 를 사용. Predicate 를 생성한다.

## 정렬과 페이징
- `Sort` 를 사용해서 알맞게 정렬 쿼리를 생성한다.
- `Pageable` 타입 파라미터를 사용
- 처음부터 N개 데이터만 필요할 경우, findFirstN 을사용할수도 있다.
- `findTop` 을 사용해도된다.

## 스펙 빌더 클래스
- `SpecBuilder` 를 만들어 사용하기도 한다.
## 동적 인스턴스와 @Subselect
- 조회 전용 모델을 만들수있다. (XXXView)
	- 표현 영역을 통해 사용자에게 데이터를 보여주기 위한 목적
- `@Subselect` 쿼리 결과를 @Entity 로 매핑할 수 있는 기능. 하이버네이트 전용 어노테이션
	- @Immutable, @Synchronize

# 질의응답사항
- 동적쿼리 생성시 QueryDSL 은 스프링에서 공식으로 지원해주지 않기때문에 책에 있는 공식적으로 지원해주는 사항을 사용하기도 한다.
---
# 6. 응용  서비스와 표현 영역
- 응용 서비스는 표현 영역에 의존하지 않는다.
- 응용 영역은 사용자가 웹 브라우저를 사용하는지 REST API 를 호출하는지, TCP 소켓을 사용하는 지를 알 필요가 없다.
## 응용서비스의 역할
- 응용 서비스의 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것. 표현 영역입장에서 보았을 대, 응용 서비스는 도메인의 영역과  표현 영역을 연결해주는 창구 역할을 한다.
- 응용 서비스는 주로 도메인 객체 간의 흐름을 제어하기 때문에 단순한 형태를 갖는다.
	- 복잡하다면 도메인 로직의 일부를 구현하고 있지는 않는지 주의. 도메인 로직은 도메인 영역에 위치하고, 응용 서비스는 도메인 로직을 구현하지 않는다.
- 트랜잭션 처리도 담당한다.
## 응용 서비스는 도메인로직을 구현하지 않는다.
- 도메인 영역과 응용 서비스에 분산해서 구현하면, 코드 품질에 문제가 발생
- 문제1: 코드 응집성이 떨어진다.
- 문제2: 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.
- 결과적으로 코드 변경에 불리하게 만든다. -> 소프트웨어의 가치가 떨어진다.
## 응용 서비스의 구현
- 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데, 이는 디자인 패턴에서 파사드 facade 와 같은 역할을 한다.
- 크기 설정
	- 한 응용 서비스 클래스에 도메인의 모든 기능을 구현할 것인가?
	- 구분되는 기능별로 응용 서비스 클래스를 따로 구현할 것인가?
- 한 응용 서비스 클래스에 모든 기능을 구현하는 경우
	- 동일한 로직을 위한 코드 중복을 제거하기 쉽다.
	- 한 클래스가 커지고, 불필요한 로직이 들어갈 수 있다. -> 관리가 어려워진다.
- 구분되는 기능별로 서비스 클래스를 구현하는 방식
	- 하나의 응용 서비스 클래스에서 1개 내지 2~3개의 기능을 구현하는 정도
	- 코드 품질을 일정 수준으로 유지하는데 도움이 된다.
- 인터페이스가 필요할까?
	- 인터페이스가 필요한 상황
		- 구현 클래스가 여러개 인 경우 : 런타임에 구현 객체를 교체해야할 때
		- TDD를 한다면, 응용 서비스의 인터페이스부터 작성해서 테스트를 한다. 그러나, Mockito 와 같은 테스트 도구틑 인터페이스가 없어도 표현 영역 테스트를 할 수 있다.
- 응용서비스의 리턴값
	- 애그리거트 자체를 리턴하면, 도메인 로직 실행을 응용서비스, 표현 영역 둘 다 할수있다.
	- 응용 서비스는 표현 영역에서 필요한 데이터만 반환하는 것으로 기능 실행 로직의 응집도를 높인다.
- 표현 영역에 의존하지 않기
	- 응용 서비스만 단독으로 테스트하기 어려워진다.
	- 응용 서비스가 표현 영역의 기술을 사용하지 않도록 한다. -> **서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는다.**
- 트랜잭션 처리
	- 트랜잭션 관리하는 것은 응용 서비스의 중요한 역할
	- 스프링 프레임워크가 제공하는 트랜잭션 관리 기능을 사용하면 좋다.
		- 간단한 설저안으로 커밋, 롤백이 가능하다.

## 표현 영역
- 책임
	- 사용자가 시스템을 사용할 수 있는 흐름을 제공하고 제어한다.
	- 사용자의 요청을 알맞은 **응용 서비스에 전달하고 결과를 사용자에게 제공**한다.
	- **사용자의 세션을 관리**한다.
- 세션을 관리한다는 것
	- 쿠키, 서버 세션을 이용해 사용자의 연결 상태를 관리한다.

## 값 검증
- 모든 값에 대한 검증은 응용 서비스에서 처리한다.
	- 파라미터로 전달받은 값이 올바른가?
- 응용서비스에서 에러코드를 모아 하나의 익셉션으로 발생시킬 수 있다.
- 스프링에서는 값 검증을 위한 Validator 인터페이스를 제공하므로, 표현영역에서 이를 간결하게 줄일 수도있다.
	- 응용 서비스는 ID중복 여부 등 논리적 오류만 검사한다.

## 권한 검사
- 표현영역
	- 인증된 사용자인지 아닌지 (ex. 서블릿 필터)
- 응용서비스
	- 권한 검사를 각 도메인 서비스에 일임
- 도메인
- 프레임워크에 검사 기능을 통합할수있으나, 이해도가 높지 않아 프레임워크를 원하는 수준으로 사용할 수 없다면, 도메인에 맞는 검사 기능을 직접 구현하는 것이 코드 유지 보수에 유리

## 조회 전용 기능과 응용 서비스
- 응용 서비스가 불필요하다면 굳이 서비스를 만들지 않아도된다.
---
# 7. 도메인 서비스
- 한 애그리거트로 기능을 구현할 수 없을 때 억지로 특정 애그리거트에 구현하면
	- 애그리거트는 책임 범위를 넘어서는 기능을 구현하기 때문에 코드가 길어지고 외부 의존도가 높아진다.
	- 코드가 복잡해 수정이 어렵게 되는 요인
	- 애그리거트의 범위를 넘어서는 도메인 개념이 애그리거트에 숨어들어 명시적으로 드러나지 않음.
- **한 애그리거트로 기능을 구현하기 힘들때는, 도메인 기능을 별도 서비스로 구현한다.**
## 도메인 서비스
- 계산 로직에 사용한다.
	- 여러 애그리거트가 필요한 계산로직 혹은 한 애그리거트에 넣기에는 다소 복잡한 계산 로직
	- 도메인의 의미가 드러나는 용어를 타입과 메서드 이름으로 갖는다.
	- 응용서비스는 애그리거트 객체에 도메인 서비스 전달
		- 사용주체는 애그리거트가 된다.
		- ==? 특이한 형태. 도메인 내부로 캡슐화할 필요가 있을 때, 사용하면 좋겠다.==
	- 도메인 서비스의 기능을 실행할 때, 애그리거트를 전달하기도 한다.
	- 애그리거트에 의존성 주입하지 않도록한다.
		- 도메인 객체의 필드는 데이터와 메서드를 이용해서 개념적으로 하나의 모델을 표현한다.
		- 일부 기능을 위해 굳이 서비스 객체를 애그리거트에 의존성 주입할 이유는 없다.
- 외부 시스템 연동이 필요한 도메인 로직
	- 구현하기 위해 타 시스템을 사용해야 하는 도메인 로직
	- 도메인 로직 관점에서 인터페이스를 작성한다. -> 구현 클래스는 인프라스트럭처 영역에 위치해 연동을 포함한 검사 기능을 구현한다.
- 도메인 서비스는 다른 도메인 구성요소와 동일한 패키지에 위치한다.
	- 로직이 고정되어 있지 않은경우, 인터페이스를 동일한 패키지에 위치시키고, 실제 구현은 인프라스트럭처 영역에 위치한다.
---
# 8. 애그리거트 트랜잭션 관리
## 애그리거트와 트랜잭션
- DBMS 가 지원하는 트랜잭션과 함께, 애그리거트를 위한 추가적인 트랜잭션 처리 기법도 필요하다.
	- 선점 잠금과 비선점 잠금 두가지 방식이 있다.
## 선점 잠금
- Pessimistic Lock
- 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지, 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식
![[Pasted image 20260211213843.png]]

- 한 스레드(작업흐름이라고 하는게 더 적당할지도?) 가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로, 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.
- 선점 잠금은 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현한다.
	- JPA의 경우, JPA EntityManager는 LockModeType을 인자로 받는 find () 메서드를 제공한다.
	- Spring 에서도 가능 `@Lock(LockModeType.PESSIMISTIC_WRITE)
	- ==Postgresql기준으로 보면==
```
SELECT * 
FROM product 
WHERE id = 1
FOR UPDATE;
```
- PostgreSQL 기준 동작방식
	- row마다 `xmin/xmax` 트랜잭션 정보 존재 
	- lock table에 row lock 기록
	- MVCC 기반이지만 → FOR UPDATE는 실제로 row-level lock을 생성
- 장점
	- 데이터 정합성을 강력하게 보장
	- Lost Update 방지
	- 재고/금융 도메인에서 완전
- 단점
	- 대기 시간 발생
	- 트래픽 많으면 병목
	- 데드락 위험
	- 확장성 떨어짐
	- 고동시성 환경에서 병목지점이 됨
### 교착상태 (데드락) 을 조심해야한다.
- 상대적으로 사용자 수가 많을 때 발생할 수 있다.
- 잠금을 구할때 최대 대기시간을 지정해야한다.
	- JPA의 경우 다음과같은 hint 를 사용할 수 있다. `hints.put("javax.persistence.lock.timeout", 2000)`
```
@Lock(LockModeType.PESSIMISTIC_WRITE)
@QueryHints(
    QueryHint(name = "jakarta.persistence.lock.timeout", value = "3000")
)
```

	- Postgresql `SET lock_timeout = '3s';`, `SET LOCAL lock_timeout = '3s';`
```
SELECT * 
FROM product 
WHERE id = 1
FOR UPDATE NOWAIT; // 락이 있으면 즉시 실패
```
```
SELECT *
FROM product
FOR UPDATE SKIP LOCKED; // 잠긴 row 는 건너뜀.
```

- 타임아웃이 발생하는 경우
	- 트랜잭션은 롤백됨.
	- 애플리케이션 레벨에서 재시도 전략 필요.

## 비선점 잠금
- 비선점 잠금은 동시에 접근하는 것을 막는 대신, 변경한 데이터를 실제 DBMS 에 반영하는 시점에 변경 가능 여부를 확인하는 방식
![[Pasted image 20260211215202.png]]
- JPA의 경우
	- `@Version` 어노테이션을 사용한다.
- Postgresql의 경우,
```
ALTER TABLE product
ADD COLUMN version BIGINT NOT NULL DEFAULT 0;

UPDATE product
SET stock = stock - 1,
    version = version + 1
WHERE id = :id
  AND version = :expectedVersion
  AND stock > 0;
  
// 버전이 없는 경우
UPDATE product
SET stock = :newStock
WHERE id = :id
  AND stock = :oldStock;
```

- 여러 트랜잭션으로 확장하고싶다면,
	- 애그리거트 정보를 뷰로 보여줄 때, 버전 정보도 함께 사용자 화면에 전달해야한다. -> 버전값이 서버에 함께 전달되도록한다.
	- 응용 서비스는 전달받은 버전 값을 이용해서 애그리거트 버전과 일치하는지 확인하고, 일치하는 경우에만 기능을 수행
- 루트 엔티티의 값이 바뀌지 않았더라도, 애그리거트 구성요소 중 일부 값이 바뀌면 논리적으로 그 애그리거트는 바뀐것. -> 버전을 올려야만한다.
	- LockModeType.OPTIMISTIC_FORCE_INCREMENT
	- 트랜잭션 종료 시점에 버전 값 증가 처리를 한다.
	- ==? 값이 무언가가 바뀌었는지는 그냥 추정하면 되나? 혹은 바뀌지 않았더라도 상관없을지도.==

## 오프라인 선점 잠금
- 엄격하게 데이터 충돌을 막고 싶다면, 누군가가 수정 진입할때 다른 사람은 수정화면 자체를 실행하지 못하게하는 방법
- 여러 드랜잭션에 걸쳐 동시 변경을 막는다.
- 데드락 주의
	- 유효시간을 반드시 설정할 것
- ==? 분산락과의 차이점?==

|구분|오프라인 잠금|분산락|
|---|---|---|
|목적|사용자 충돌 방지|서버 간 동시 실행 방지|
|범위|데이터 단위|작업 단위|
|저장 위치|DB 컬럼|Redis/DB|
|유지 시간|길 수 있음|짧아야 함|
|사용 예|문서 편집|배치/정산|

- 구현방식

| 구분      | 오프라인 잠금 | 분산락      |
| ------- | ------- | -------- |
| 구현 계층   | 도메인/DB  | 인프라      |
| 저장 위치   | 테이블 컬럼  | Redis/DB |
| 트랜잭션 유지 | 없음      | 없음       |
| TTL 필요성 | 선택      | 필수       |
| 네트워크 의존 | 없음      | 있음       |
| 서버 수 영향 | 무관      | 중요       |

- 오프라인 잠금이 맞는 경우
	- 관리자가 긴 시간 수정
	- UI 상 “다른 사용자가 편집 중” 표시 필요
- 분산락이 맞는 경우
	- 여러 인스턴스에서 배치 실행
	- 결제 정산 1회 보장
	- 중복 실행 치명적
- ==? 오프라인 잠금 사용사례?==