## 실드패턴 shield pattern
- 먼저 모든 값의 정합성(밸리데이션)을 계산함.
- 정합하지 않은 값이 있으면 로직을 종료함.
- 이후 정합한 값을 이용하는 비지니스 로직만 전개함.
- 로직이 정합성 계산과 비지니스 로직이 섞이면 유지보수가 어렵기 때문임.
- 이 때문에 DB조회를 2번 하더라도 밸리데이션 -> 비즈니스 로직을 분리하는 것임.
### 정합성의 종류
1. 필수와 선택
2. 값 자체 정합 : 일치, 범위, 포함, 특수 조건
3. 값 간의 관계
4. 값이 다른 대상을 가리키는 경우
### 정합성 처리 방법
- 1개가 발견되면 즉시 중지 -> 에러가 클라이언트에 하나씩 반환됨
- 여러개를 다 검사하여 정합하지 않은 값을 전부 계산 -> 이게 힘듬
## 밸리데이션
1. 밸리데이션은 직접 정의와 추상 정의가 있다.
	- 직접 정의 : 밸리데이션 로직 기술
	- 추상 정의 : 이미 그 타입인 것으로 밸리데이션이 되어 있음을 증명
2. 직접 정의를 위한 풍부한 타입별 밸리데이터를 활용
3. OAS의 밸리데이터는 기본적으로 AND 조합임
4. 그룹화된 OR을 사용하려면 object + oneOf 조합 써야함
## 밸리데이션 추상 정의

# API 버전
## 버전 구분
- major : 사용자측의 코드를 변경해야함
- minor : 사용자축의 코드를 변경하면 더 좋아지지만 유지해도 됨

## 전체버전 vs 엔드포인트별 버전
- 전체 : 서비스 전체의 일관성이 유지됨
- 엔트포인트 : 부분 업데이트를 기민하게 할 수 있음
- 기타버전 시스템
	- 채널 운영 : 알파, 베타, 까나리 등

## 구버전 운영
1. 버전 공지 정책
	1. deprecated 대안이 있을 경우
	2. remove 삭제
2. 구버전도 운영
	1. 종료일을 정해야함
	2. 마이그레이션 유도 (기능 차별, 혜택 감소)
	3. 단계별 종료 (기능별, 처리량이나 빈도별)

# 테스트 가이드
- 얼마나 많은 케이스를 테스트 할 것인가? 진리표 작성
- 하나의 값을 어디까지 테스트할까? 오른쪽 이두박근 (괄호는 예시)
	- right 올바른가? (1~10 정수 숫자)
	- Boundary 경계조건 (1, 10)
	- inverse 역관계 (0, -1, 11, "a", 5.5...)
	- crosscheck 교차 검증 (v%10 -> 0~9)
	- error condition 에러 처리 확인 = 응답값 에러 출력
	- performance 성능이 허용범위 내인가 = 시간, 메모리 측정
- 