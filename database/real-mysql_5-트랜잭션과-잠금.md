# 📖 5. 트랜잭션과 잠금
## 들어가기 전에
- 잠금과 트랜잭션의 차이
    - 잠금 : 동시성을 제어하기 위한 기능
    - 트랜잭션 : 데이터의 정합성을 보장하기 위한 기능
- 격리수준 : 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

## 5.1 트랜잭션
### 5.1.1 MySQL에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용(COMMIT)되거나 아무것도 적용되지 않아야(ROLLBACK 또는 오류)함을 보장해주는 것입니다.

- MyISAM은 부분 업데이트로 처리하기 때문에 오히려 실패된 작업을 재시작할 때 곤란을 겪습니다.

### 5.1.2 주의사항

- 프로그램 코드에서 트랜잭션의 범위를 최소화하는 것이 좋습니다.
- 트랜잭션 내에 네트워크 작업은 반드시 배제해야 합니다.

DBMS 서버가 높은 부하 상태로 빠지거나 위험한 상태로 빠질 수 있습니다.

## 5.2 MySQL 엔진의 잠금
두 가지 잠금이 있습니다.

- 스토리지 엔진 레벨
- MySQL 엔진 레벨

스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않습니다, 하지만 MySQL 엔진에서는 모든 스토리지 엔진에 영향을 줍니다.

MySQL 엔진의 락은 다음의 종류들이 있습니다.

- 테이블 데이터 동기화를 위한 **테이블 락**
- 테이블 구조를 잠그는 **메타데이터 락**
- 사용자의 필요에 맞게 사용할 수 있는 **네임드 락**

## 5.2.1 글로벌 락 Global lock

- MySQL에서 제공하는 잠금 가운데 가장 범위가 큽니다.
- `FLUSH TABLES WITH READ LOCK`
- 다른 세션에서 SELECT를 제외한 모든 DDL, DML을 글로벌 락이 해제될 때까지 대기해야 합니다.

<aside> 🤔 **세션이 뭐지?**

- 인스턴스 안에 있는 논리적인 실체로 현재 유저의 로그인 상태 </aside>
    
- InnoDB 스토리지 엔진은 트랜잭션을 지원해서 기존 글로벌 락보다 가벼운 글로벌 락이 도입될 필요가 생겼습니다.
    
    - MySQL 8.0부터 백업락 도입되었습니다.

### 백업 락

- 일반적인 테이블의 변경은 허용됩니다.
- 레플리카 서버에서 실행됩니다.
- MySQL 서버의 백업 락은 정상적으로 복제는 실행되지만 백업의 실패를 막기 위해 DDL 명령이 실행되면 복제를 일시 중지합니다.
- 물론 `XtraBackup` 이나 `Enterprise Backup` 과 같은 백업 툴은 글로벌 락 상황에도 쓰기가 가능해 복제를 진행하며 일관된 백업이 가능합니다. 하지만 백업 도중 DDL 명령 하나로 인해 백업 실패할 수도 있습니다.

## 5.2.2 테이블 락

- 개별 테이블 단위로 설정되는 잠금
- 명시적/묵시적으로 특정 테이블의 락을 획득합니다.

### 명시적 테이블 락

```java
LOCK TABLES {table_name} [ READ | WRITE ]

UNLOCK TABLES
```

### 묵시적 테이블 락

- MyISAM이나 MEMORY 테이블에서 데이터를 변경하는 쿼리를 실행하면 발생
    - 테이블을 잠그고 데이터를 변경한 후 잠금을 해제하는 형태
- InnoDB 의 경우 DDL 의 경우에만 영향을 미칩니다.

## 5.2.3 네임드 락

- 사용자가 지정한 문자열에 대해 락을 획득하고 반납하는 락입니다.
- 자주 사용되지는 않습니다.
- MySQL 8.0 부터는 네임드 락을 중첩해서 사용할 수 있게 되었으며, 한번에 해제할 수도 있습니다.

```java
SELECT GET_LICK('mylock_1',10);

SELET RELEASE_ALL_LOCKS();
```

## 5.2.4 메타데이터 락

- 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금입니다.
    - 여기서 데이터베이스의 객체란 테이블, 뷰 등을 말합니다.
- 명시적으로 획득/해자할 수는 없고, 테이블 이름을 변경하는 경우 자동으로 획득하곤 합니다.
- _165pg, 메타데이터락과 다른 트랜잭션을 함께 사용하는 예제 있음_

## 5.3 InnoDB 스토리지 엔진 잠금
- MySQL 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있습니다.
- 최근 버전의 InnoDB는 현재 어떤 트랜잭션이 잠금을 대기하고 잠금을 어떤 트랜잭션이 가지고 있는지 확인할 수 있습니다.
    - information_schema
        - INNODB_TRX
        - INNODB_LOCKS
        - INNODB_LOCK_WAITS
- Performance Schema를 이용해 InnoDB 스토리지 엔진의 내부 잠금에 대한 모니터링방법도 추가되었습니다.
    - 세마포어 : MySQL에서 세마포어는 InnoDB 엔진의 내부 기능 중 하나입니다. 세마포어는 스레드 간의 동기화를 담당하며, 뮤텍스나 리드/라이트 락 세마포어를 기다리는 스레드에 대한 정보를 제공합니다. 이 정보는 주로 세마포어의 통계를 나타내며, InnoDB 엔진이 시작된 이후부터의 세마포어의 사용 현황을 나타냅니다.

### Shared lock & Exclusive Lock

||공유 락|배타 락|
|---|---|---|
|공유 락|허용|대기|
|배타 락|대기|대기|

```java
SELECT ... FOR SHARE

SELECT ... FOR UPDATE
```

### 5.3.1 InnoDB 스토리지 엔진의 잠금

- InnoDB 스토리지 엔진은 레코드 기반의 잠금기능을 제공합니다.
- 잠금 정보가 작은 공간으로 관리되어 레코드 락이 더 큰 규모의 락으로 레벨업 되는 경우는 없습니다. (락 에스컬레이션이 없습니다.)
- 레코드와 레코드 사이의 간격을 잠그는 갭(GAP)락이 존재합니다.

![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F1feb7462-9c33-4bf1-b0bb-7973d34ffaf2%2Fe109b3cc-d5cf-482a-a8db-9e75148b234c%2FUntitled.png?table=block&id=100d216a-13d3-4a3f-b1bb-63b26e6e0d08&spaceId=1feb7462-9c33-4bf1-b0bb-7973d34ffaf2&width=2000&userId=180a704c-6552-4796-9dd2-ab125439ed98&cache=v2)

#### 5.3.1.1 레코드 락

- 레코드 자체만을 잠그는 락입니다.
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 “인덱스의 레코드를 잠급니다.”
- 인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정합니다.
- 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭(Gap)에 대해서 잠그지 않고 레코드 자체에 대해서만 락합니다.
    - 대부분 보조 인덱스 이용한 변경 작업은 넥스트 키락 또는 갭락을 사용합니다.

#### 5.3.1.2 갭 락

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠급니다.
- 레코드와 레코드 사이 간격의 새로운 레코드가 생성되는 것을 제어하기 위함입니다.
- 넥스트 키락의 일부로 자주 사용됩니다.

#### 5.3.1.3 넥스트 키 락

- 레코드락과 갭락을 합쳐 놓은 형태의 잠금입니다.
- InnoDB의 갭락이나 넥스트 키락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적입니다.
- 그러나 의외로 넥스트 키락과 갭락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 하는 일이 자주 발생합니다.
- 그러니 가능하면 바이너리 로그 포맷을 ROW 형태로 바꿔 넥스트 키락, 갭락을 줄이는 것이 좋습니다.

#### 5.3.1.4 자동 증가 락

- AUTO_INCREMENT 라는 칼럼 속성을 쓸 경우, 내부적으로 이를 조회하기 위한 락을 순식간에 걸었다가 해제합니다.
- UPDATE나 DELETE 등의 쿼리에서는 걸리지 않습니다.
- 해당 락은 테이블에 단 하나만 존재하기 때문에 두 개의 INSERT 쿼리가 동시에 실행된다면 하나씩 락을 획득하여 처리합니다.

```jsx
innodb_autoinc_lock_mode=1
```

- 0일 경우, MySQL 5.0과 동일한 잠금방식을 사용합니다.
- 1일 경우, MySQL서버가 정확히 INSERT 레코드 건수를 정확히 예측할 수 있다면 자동 증가 락보다 훨씬 가볍고 빠른 래치(뮤텍스)를 이용해처리합니다.
    - 예측할 수 없을 때는 자동 증가락을 사용합니다.


### 5.3.2 인덱스와 잠금

- InnoDB는 레코드를 잠그는 방식이 아니라 인덱스의 레코드를 모두 락을 거는 방식으로 처리됩니다.
    - 변경해야 할 레코드를찾기 위해 검색한 인덱스의 레코드를 모두 락을 거는 것입니다.
- 만약 테이블에 인덱스가 하나도 없다면, 테이블을 풀 스캔하면서 작업하는데 이 과정에서 테이블의 모든 레코드가 잠기게 됩니다.

### 5.3.3 레코드 수준의 잠금 확인 및 해제

- MySQL 5.1부터 레코드 잠금과 잠금 대기에 대한 조회가 가능합니다.
- 강제 잠금을 해제하려면 KILL 명령을 통해 MySQL 서버의 프로세스를 강제로 종료하면 됩니다.

```jsx
performance_schema
data_locks, data_lock_waits 테이블
```

![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F1feb7462-9c33-4bf1-b0bb-7973d34ffaf2%2Fb83c67ff-be21-4b23-b2a3-a013381199fc%2FUntitled.png?table=block&id=32c66561-ee80-435c-9132-ce6efe18452b&spaceId=1feb7462-9c33-4bf1-b0bb-7973d34ffaf2&width=2000&userId=180a704c-6552-4796-9dd2-ab125439ed98&cache=v2)

## 5.4 MySQL의 격리 수준

- 트랜잭션의 격리 수준이란, 여러 트랜잭션이 동시엥 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지를 결정하는 것입니다.
- 크게 4가지수준이 있습니다.

![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F1feb7462-9c33-4bf1-b0bb-7973d34ffaf2%2F9fb1f292-6a52-4f7d-ae58-9b4f3c9efbe8%2FUntitled.png?table=block&id=caa954d2-4df8-4d10-8464-b110b96fd8a3&spaceId=1feb7462-9c33-4bf1-b0bb-7973d34ffaf2&width=2000&userId=180a704c-6552-4796-9dd2-ab125439ed98&cache=v2)

![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F1feb7462-9c33-4bf1-b0bb-7973d34ffaf2%2F8e80eb9a-8f01-4496-93a6-f4adf07e7929%2FUntitled.png?table=block&id=b82ba38d-8596-40a1-82e0-3604f658dea7&spaceId=1feb7462-9c33-4bf1-b0bb-7973d34ffaf2&width=2000&userId=180a704c-6552-4796-9dd2-ab125439ed98&cache=v2)
